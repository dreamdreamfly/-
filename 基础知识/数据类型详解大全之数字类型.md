# number数据类型
- 包括
   + 正数、负数、小数、零
   + NaN：not a number 不是一个有效数字，但是属于number类型 NaN和任何值都不相等，包括他自己
   + Infinity:无穷大 也是number类型的 isNaN(infinity) => false
- isNaN：验证一个值是否是非有效数字，如果是有效数字为false
- 把其他数据类型转换为数字类型的方法
   + Number([value]):是JS呢只的转换方法，可以把其它数据类型"强制"转换为数字类型
      + 字符串转为数字：只要出现一位非有效数字就会转换为NaN，但是可以识别一位小数点。
      > 空字符串转为数字是0
      + 布尔值转为数字：true是1，false是0
      + 把空转换为数字：null是0，undefined是NaN
      + 不能把Symbol类型转换为数字类型，否则会报错
      + 对象转换为数字：先把对象转为字符串，再把字符串转换为数字
        - 普通对象，转换为字符串是"[object Object]",转换为数字是NaN
        + 数组对象，转换为字符串是把数组内的每一项用逗号隔开，在用引号包起来，最后在转换为数字类型
        + 其余对象格式基本上都是NaN
      + 函数转换为数字都是NaN，先把函数加上引号变为字符串，在转换为数字是NaN
   + parseInt([value])/parseFloat([value])：处理原理和Number不一样，他们是把字符串转换为数字(如果处理的数据不是字符串类型需要先转换为字符串类型)
     + parseInt：从字符串最左边开始查找，把找到的有效数字字符转换为数字，一直遇到一个非有效数字字符为止，则结束查找。如果没有有效数字就是NaN
     + parseFloat：比parseInt多识别一位小数点
- 数字类型的方法
   + 3.1415926.toFixed(n):保留小数点后面n位(最后的结果是一个字符串，会进行四舍五入)
   + console.log(Number.MAX_SAFE_INTEGER) =>9007199254740991 最大安全数(JS能够有效识别的最大整数) console.log(9007199254740992 == 9007199254740993) => true 应该是不一样的，但是超过了最大数值，JS无法精准计算。ES6提供了一个新的数据类型 BigInt:管理超过安全数值的数字
# JS中，比较两个值是否相等，有以下方法
  + == 相等 如果数据类型不一样，默认需要转换为相同数据类型在比较   [] == [] =>false(引用数据类型比较的是空间地址)
  + === 绝对相等 数据值和数据类型都相等
  + Object([value1],[value2]) ES6
> + ==、数学运算、isNaN采用的都是Number()
> + a = b ={n:1} 顺序：先创建值{n:1},再把值从左到右依次赋值 a = {n:1},b = {n:1}
> + let a = 1 b = ++a 先运算再取值 b = a++ 先取值在运算